# 백엔드 서버

## 개요
클라이언트로 부터 번역 요청을 전달받고 log를 남기고 사용자 의견을 수집하는 등의 기능을 하는 spring boot 기반의 서버입니다.

## 굳이 백엔드 서버가 필요한가요?
단순 번역을 위한 애플리케이션을 만들거면 사용하지 않아도 되지만 log를 수집하고 사용자들이 어떤 입력을 하는지 분석을 하기 위해서 DB에 사용자 입력과 번역 결과를 저장해야겠다 생각하여 백엔드 서버를 만들었습니다. 이것 또한 API 서버에서 한번에 처리가 가능하지만 API 서버는 단순히 번역 요청이 오면 번역만 해주는 기능을 하는것이 나중에 기능 수정을 통한 변경에서 영향을 받지 않는다는 생각도 하였습니다. 또한 새로운 요구사항이 추가되거나 기능을 추가했을때 백엔드 서버에서 구현하면 되기 때문에 이 부분에 큰 장점이 있다고 생각했습니다.

## 왜 무거운 스프링을 이용하였나요?
이 프로젝트는 간단한 애플리케이션이고 다른 프레임 워크를 이용하는게 규모가 더 작을수 있지만 학습 목적이 제일 컸습니다.  스프링을 이용한 프로젝트 진행 경험이 없었고 이번 기회에 스프링 프로젝트를 진행하면서 스프링의 Layered Architecture나 Ioc Container, Web Client 등 여러 기술을 익히고 사용해 볼 수 있는 기회라고 생각하였습니다.

## https 문제

요구 사항에서 음성 인식을 통해 앱과 웹에서 사용자 발화를 text로 추출할 수 있어야 합니다. 그런데 http를 사용할 경우 웹 브라우저에서 마이크 접근 권한을 거부하기 때문에 https를 사용해야 합니다. https를 이용하여 클라이언트와 통신할 경우 http를 사용할 수 없기 때문에 https를 사용해야 하는 문제가 있었습니다.
관련된 문제를 해결하기 위해서 다음과 같은 해결책이 제시되었습니다.

1. https를 이용하여 통신한다.
2. kafka를 이용한 메세지 전달을 이용하여 통신한다.
3. gradle을 이용하여 react와 spring을 같이 build하여 하나의 서버에 https를 요청한다.

https는 http에서 SSL(Secure Sockets Layer)를 추가한것과 같습니다. 프로젝트에 https를 적용할 수 있도록 가상으로 key를 발급받아서 사용하였습니다. 물론 학교 프로젝트이며 당장 사용자에게 서비스하지 않고 데모를 하기 위해서 가상으로 발급받은것이지 실제로 서비스나 중요한 프로젝트에서는 인증을 받은 key를 발급받아 사용해야 합니다.

1번 해결책의 경우 react 프로젝트에서 발급한 key에 대한 정보를 알아야 한다는 점이 있었습니다. react에서 https를 위한 운용은 그렇게 어렵지 않다는것을 알았지만 이번 프로젝트를 진행하면서 발생하는 여러 문제점에 대한 학습의 목표도 있었기 때문에 2번의 해결책으로 진행해봤습니다.
2번 해결책인 kafka의 경우에서 사용자가 데이터를 kafka broker에게 바로 전달하고 API 서버에서 consume하여 획득한 데이터를 번역하여 다시 broker에게 전달하는 방식으로 해보았습니다.
메세지 전달 과정에서 서로 다른 언어를 사용하기 때문에 BytesSerializer를 사용해야했고 추가로 바이트 코드의 저장 순서가 맞지 않아 생기는 문제점이 있었습니다. 따라서 바이트 순서를 맞추기 위해서 API 서버에서 빅엔디안 방식으로 전달된 바이트를 리틀 엔디안으로 변경하여 데이터를 처리하고 다시 빅 엔디안으로 전송하도록 하였습니다.
그러나 멀티 쓰레드 환경에서 broker에게 전달한 메세지는 동시성 문제를 가지고 있었습니다. 한 토픽은 여러 파티션으로 이루어져있는데 이 파티션에서 consume을 하는 순서가 보장되어있지 않기 때문에 순서가 뒤죽박죽일 수 있겠다는 생각을 하였습니다. 그보다도 producer에서 동시에 요청을 할 경우 접근을 제한하였기 때문에 이 해결책을 사용할 수 없었습니다.

따라서 3번째 해결책을 이용하였습니다. gradle을 사용하여 react와 spring을 같이 빌드하여 정적 페이지를 react의 빌드 파일에서 제공하고 spring은 요청 받은 데이터를 전달하는 방식으로 운영하였습니다. 이렇게 하면 빌드에 시간이 오래 걸리고 수정이 잦아진다는 문제가 있었지만 불필요하게 react에서도 호스팅하고 spring으로도 호스팅하는 번거로운 일이 없었습니다.

